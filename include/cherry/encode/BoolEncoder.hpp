#ifndef _CHERRY_ENCODE_BOOL_ENCODER_HPP_INCLUDED_
#define _CHERRY_ENCODE_BOOL_ENCODER_HPP_INCLUDED_

#include <stdint.h>
#include <cherry/except/BufferOverflow.hpp>

namespace cherry {

class BoolEncoder {
public:
	BoolEncoder(void* output, size_t size, uint8_t probability)
			: probability(probability), shift(24) {
		stream.buffer = static_cast<unsigned char*>(output);
		stream.cursor = stream.buffer;
		stream.size = size;
		interval.bottom = 0;
		interval.length = 255;
	}

	void flush();

	size_t getOutputSize() const {
		return stream.cursor - stream.buffer;
	}

	void encode(const void* data, size_t size) {
		// The implementation is kind of tricky. Static data member
		// *functionTable* are all the 256 possible instances of function
		// template *addByte()*. *addByte()* is implemented as a function
		// template in the hope that the compiler will do substantial inline,
		// and apply constant folding optimization.
		const unsigned char* p = static_cast<const unsigned char*>(data);
		for (size_t i = 0; i < size; ++i) {
			(functionTable[p[i]])(this);
		};
	}

private:
	typedef void (*EncodingFunction)(BoolEncoder*);

	// The definition is generated by script "BoolEncoder_functionTable.py"
	static EncodingFunction functionTable[256];

	struct {
		unsigned char* buffer;
		unsigned char* cursor;
		size_t size;

		void append(uint8_t data) {
			if (cursor - buffer >= (ptrdiff_t)size) {
				RAISE(BufferOverflow, "Output buffer is full");
			}
			*cursor = data;
			++cursor;
		}
	} stream;
	struct {
		uint32_t bottom;
		uint32_t length;
	} interval;
	uint8_t probability;
	int shift;

	template<unsigned char BYTE>
	static void addByte(BoolEncoder* encoder) {
		for (int i = 7; i >= 0; --i) {
			encoder->addBool(BYTE & (1 << i));
		}
	}

	void propagateCarry();

	void addBool(bool value) {
		uint32_t length = 1 + (interval.length - 1) * probability / 256;
		if (value) {
			interval.bottom += length;
			interval.length -= length;
		} else {
			interval.length = length;
		}

		while (interval.length < 128) {
			interval.length *= 2;
			if (interval.bottom & (1 << 31)) {
				propagateCarry();
			}
			interval.bottom *= 2;
			--shift;
			if (shift == 0) {
				stream.append(interval.bottom >> 24);
				interval.bottom &= (1 << 24) - 1;
				shift = 8;
			}
		}
	}
};

} // namespace cherry

#endif // _CHERRY_ENCODE_BOOL_ENCODER_HPP_INCLUDED_

